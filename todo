- i think we should break query up into many factors and create results from all of them, rather than just the single factorization. i'm thinking something between single factorization and all substrings. because we are clearly missing out on good results because of a mismatch of query factors and possible-result-doc factors
- the ways these are scored (in the runAll) in stupid
- snippets are important to evaluate the document
- seems more recently indexed documents score higher (i think because the code length is longer)
  - could try not using cover
  - could also try using some sort of entropy metric or 'factor length  and frequency distribution' metric to ensure each document is indexed in a commensurate way
- limit max length of code to documents are not divided into sets based on the length of their factors
- when the dictionary has the code we add the current document to it
- let's index a query but only the first time we get it?
- i think we should look at all substrings of the query (all possible factorizations)
- add evaluation dataset
  - trying textfiles.com archives
  - try those listed here: https://github.com/RediSearch/ftsb
  - also consider https://the-eye.eu/public/AI/pile_preliminary_components/ which is also at 
    https://archive.is/wip/vgsTc
- don't pre-emptively optimise, keep the algorithm loose and open before it's thoroughly tested
- add spanish
- things we can try to improve performance:
  - the usual parameters, cover, stopping condition, score calculation,1
  - add new things like tf-idf for factors, cosine similarity (on what I don't yet know), boosting doc in (doc, query) based on how many times that doc has been the first clicked result for that query
  - joining documents across factors rather than just summing scores.
  - or summing scores, but multiplying across those factors that share a common document
- turn dicts.json into {docNames:[...], values:[....]} to remove redundancy of doc name in every record
- sync indexes to disk
- create a way to do snippets (contextual snippets to put the search result in context of the document)
- create a way to do instant (basically just indexing the queries, and querying those against the current query as it is typed)



